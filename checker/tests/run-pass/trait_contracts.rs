// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
//

// This test case demonstrates that de-virtualization for contracts on traits as they
// are generated by the contracts crate are infeasible, and that the contracts crate
// compilation scheme is not working for MIRAI.

use mirai_annotations::*;

// Without using contracts crate directly, this is what #[contract_trait] will generate.
trait Adder {
    // Get the state of the adder for use in contracts. This is a common design pattern to
    // access state of trait implementations on abstract trait level.
    fn current(&self) -> i32;

    // Original function decrement with pre/post embedded calling a newly introduced impl function.
    // That's conceptually what the conract crate generates for pre/post on trait methods.
    fn decrement(&mut self) {
        // PROBLEM: This function is not analyzable because self.current() has no summary. The
        // summary would look different for each implementer. At the callers side, we can't know
        // it (by design of virtual calls).
        checked_precondition!(self.current() > 0);
        let old = self.current();
        self._impl_decrement();
        checked_postcondition!(self.current() > old)
    }

    fn _impl_decrement(&mut self);
}

struct MyAdder(i32);

impl Adder for MyAdder {
    fn current(&self) -> i32 {
        self.0
    }

    fn _impl_decrement(&mut self) {
        // Below is needed because precondition in Adder trait is not propagated here. To
        // propagate, we would need to know that this fn is never called from anywhere else
        // then Adder.decrement.
        checked_precondition!(self.current() > 0);
        self.0 = self.0 - 1;
    }
}

pub fn main() {
    let mut a = MyAdder(3);
    a.decrement();
    checked_verify!(a.current() < 3)
}
